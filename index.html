<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>Motor Working Memory – Delayed Reach (iPad Stylus)</title>
<style>
  html, body { margin:0; padding:0; height:100%; background:#fafafa;
               font-family:system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
  #ui { padding: 12px; display:flex; gap:8px; align-items:center; flex-wrap:wrap;
        background:#fff; border-bottom:1px solid #ddd; position:sticky; top:0; z-index:2; }
  #status { font-size:14px; }
  label { font-size:14px; }
  input, select { padding:6px; }
  button { padding:8px 12px; border:1px solid #ccc; background:#fff; border-radius:6px; }
  #canvasWrap { position:relative; width:100%; height:calc(100% - 58px); display:flex; justify-content:center; align-items:center; }
  #pad { touch-action: none; background:#fff; border:1px solid #ddd; border-radius: 12px; }
  #overlay { position:absolute; inset:0; display:none; align-items:center; justify-content:center;
             text-align:left; padding:20px; background:rgba(255,255,255,0.94); font-size:18px; line-height:1.45; }
  #probeGrid { display:grid; grid-template-columns: repeat(4, 40px); gap:8px; justify-content:center; margin-top:12px; }
  .sq { width:40px; height:40px; border:1px solid #666; }
  #motorTapArea { margin-top:12px; display:flex; gap:8px; justify-content:center; }
  .tapbtn { width:60px; height:60px; border-radius:50%; border:1px solid #444; background:#eee; font-size:18px; }
  .note { font-size:14px; color:#555; }

  /* Disable text selection / callout / tap highlight to avoid iOS blue selection */
  * { -webkit-tap-highlight-color: rgba(0,0,0,0); }
  html, body, #canvasWrap, #overlay, #pad, button, label, select, input {
    -webkit-user-select: none; user-select: none; -webkit-touch-callout: none;
  }
  ::selection { background: transparent; }

</style>
</head>
<body>

<div id="ui">
  <label>Participant ID: <input id="pid" placeholder="e.g., S01" style="width:90px;"></label>
  <button id="startBtn">Start block (toolbar settings)</button>
  <button id="downloadBtn" disabled>Download CSV</button>
  <label>Condition mix:
    <select id="condMix">
      <option value="all">All (random per trial)</option>
      <option value="baseline">Baseline only</option>
      <option value="verbal">Verbal only</option>
      <option value="vis">Visuospatial only</option>
      <option value="motor">Motor only</option>
    </select>
  </label>
  <label>Delay (s):
    <select id="delaySel">
      <option>3</option><option selected>4</option><option>5</option><option>6</option>
    </select>
  </label>
  <label>Trials per block:
    <select id="nTrialsSel">
      <option>10</option><option>16</option><option selected>20</option><option>24</option><option>32</option>
    </select>
  </label>
  <span id="status"></span>
</div>

<div id="canvasWrap">
  <canvas id="pad" width="900" height="900"></canvas>
  <div id="overlay"></div>
</div>

<script>
// ====== Config ======
const R_HOME = 14;           // home marker radius (px)
const HOME_SNAP = 20;        // tolerance for 'in centre' (px)
const HOLD_MS = 3000;        // require 3s continuous contact in centre
const R_THRESH = 120;        // angle threshold radius (px)
const TARGET_RADIUS = 220;   // target distance (px)
const TARGET_MS = 500;       // target flash duration (ms)
const ANGLES = Array.from({length:16}, (_,i)=> i*(360/16));

// ====== Elements ======
const canvas = document.getElementById('pad');
const ctx = canvas.getContext('2d');
const overlay = document.getElementById('overlay');
const startBtn = document.getElementById('startBtn');
const downloadBtn = document.getElementById('downloadBtn');
const condMixSel = document.getElementById('condMix');
const delaySel = document.getElementById('delaySel');
const nTrialsSel = document.getElementById('nTrialsSel');
const pidEl = document.getElementById('pid');

const W = canvas.width, H = canvas.height;
const CX = W/2, CY = H/2;

// ====== State ======
let trials = [];
let trialN = 0;
let running = false;
  pidEl.disabled = false;
let condition = 'baseline';
let blockPlan = [];
let phase = 'idle'; // 'centre','encode','delay','recall'
let current = null;

let contact = false;       // true only while pen is touching (pressure>0 or buttons===1)
let inHomeContact = false; // contact && within HOME_SNAP
let holdStart = null;      // timestamp when continuous hold began
let homeLocked = false;    // true once HOLD_MS reached
let lastXY = {x:CX, y:CY};

// ====== Utils ======
const sleep = ms => new Promise(r=> setTimeout(r, ms));
const deg2rad = d => d*Math.PI/180;
const rad2deg = r => r*180/Math.PI;
const wrapDeg = a => { while(a>180) a-=360; while(a<=-180) a+=360; return a; };
const polarAt = (angleDeg, r) => [CX + r*Math.cos(deg2rad(angleDeg)), CY + r*Math.sin(deg2rad(angleDeg))];
const randChoice = a => a[Math.floor(Math.random()*a.length)];
const shuffle = a => { for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]] } return a; }
const now = () => performance.now();
function isContact(e){ return (e.pressure && e.pressure>0) || (e.buttons && e.buttons===1); }
function getCanvasXY(e){
  const rect = canvas.getBoundingClientRect();
  return { x: (e.clientX - rect.left) * (canvas.width/rect.width),
           y: (e.clientY - rect.top)  * (canvas.height/rect.height) };
}

// ====== Drawing ======
function drawBase(){
  ctx.clearRect(0,0,W,H);

  // home circle
  ctx.beginPath();
  ctx.arc(CX, CY, R_HOME, 0, 2*Math.PI);
  const homeFill = inHomeContact ? '#1fa12e' : '#444'; // green only when CONTACT and in centre
  ctx.fillStyle = homeFill; ctx.fill();
  ctx.lineWidth = 2;
  ctx.strokeStyle = inHomeContact ? '#0a6f1b' : '#888';
  ctx.stroke();

  // confirmation dot when 3s hold achieved
  if(homeLocked){
    ctx.beginPath();
    ctx.arc(CX, CY, 6, 0, 2*Math.PI);
    ctx.fillStyle = '#00c853'; // bright green dot
    ctx.fill();
  }

  // threshold ring (light)
  ctx.beginPath();
  ctx.arc(CX, CY, R_THRESH, 0, 2*Math.PI);
  ctx.strokeStyle = 'rgba(0,0,0,0.08)'; ctx.lineWidth=1; ctx.stroke();
}

function drawTarget(angleDeg){
  const [tx,ty] = polarAt(angleDeg, TARGET_RADIUS);
  ctx.beginPath();
  ctx.arc(tx, ty, 10, 0, 2*Math.PI);
  ctx.fillStyle = '#2a7';
  ctx.fill();
}

// ====== Conditions ======
const CONDS_ALL = ['baseline','verbal','vis','motor'];
function makeBlockPlan(mix, n, fixedCond=null){
  if (fixedCond) return Array(n).fill(fixedCond);
  let pool = [];
  if(mix==='all') pool = CONDS_ALL;
  else if(mix==='baseline') pool=['baseline'];
  else if(mix==='verbal') pool=['verbal'];
  else if(mix==='vis') pool=['vis'];
  else if(mix==='motor') pool=['motor'];
  let arr = [];
  for(let i=0;i<n;i++){ arr.push(randChoice(pool)); }
  return arr;
}

// ====== Visuospatial load ======
let visArray=null, visProbe=null;
function makeVisArray(){
  let coords = [];
  for(let r=0;r<4;r++) for(let c=0;c<4;c++) coords.push([r,c]);
  coords = shuffle(coords).slice(0,5);
  const colors = ['#f33','#36f','#0a0','#fa0','#a0f','#0aa','#aaa','#333'];
  visArray = coords.map(([r,c])=> ({r,c,color: randChoice(colors)}));
  const change = Math.random()<0.5;
  const idx = Math.floor(Math.random()*visArray.length);
  visProbe = JSON.parse(JSON.stringify(visArray));
  if(change){
    let col = visProbe[idx].color;
    let newCol = col; while(newCol===col) newCol = randChoice(colors);
    visProbe[idx].color = newCol;
  }
  visProbe.change = change;
}
function showVisArray(ms){
  overlay.style.display='flex';
  overlay.innerHTML = `<div style="text-align:center;">
    <div>Remember this pattern</div><div id="probeGrid"></div></div>`;
  const grid = overlay.querySelector('#probeGrid');
  grid.innerHTML='';
  visArray.forEach(o=>{
    const d=document.createElement('div'); d.className='sq'; d.style.background=o.color; grid.appendChild(d);
  });
  setTimeout(()=> overlay.style.display='none', ms);
}
function visProbeQuery(){
  overlay.style.display='flex';
  overlay.innerHTML = `<div style="text-align:center;">
    <div>Was the pattern the SAME or DIFFERENT?</div>
    <div id="probeGrid" style="margin-bottom:10px;"></div>
    <div style="display:flex; gap:10px; justify-content:center;">
      <button id="sameBtn">Same</button>
      <button id="diffBtn">Different</button>
    </div></div>`;
  const grid = overlay.querySelector('#probeGrid');
  grid.innerHTML='';
  visProbe.forEach(o=>{
    const d=document.createElement('div'); d.className='sq'; d.style.background=o.color; grid.appendChild(d);
  });
  return new Promise(res=>{
    overlay.querySelector('#sameBtn').onclick=()=>{ overlay.style.display='none'; res('same'); }
    overlay.querySelector('#diffBtn').onclick=()=>{ overlay.style.display='none'; res('different'); }
  });
}

// ====== Motor tapping load ======
let requiredTaps=null, tapsSoFar=[];
function makeTapPattern(){
  const len=4;
  requiredTaps = Array.from({length:len}, ()=> 1+Math.floor(Math.random()*3));
  tapsSoFar = [];
}
function showTapUI(){
  overlay.style.display='flex';
  overlay.innerHTML = `<div style="text-align:center;">
    <div>Please tap this pattern during the delay (use finger of your other hand):</div>
    <div style="margin-top:8px; font-size:18px">${requiredTaps.join(' - ')}</div>
    <div id="motorTapArea">
      <button class="tapbtn" data-k="1">1</button>
      <button class="tapbtn" data-k="2">2</button>
      <button class="tapbtn" data-k="3">3</button>
    </div>
    <div id="tapStatus" style="margin-top:8px; font-size:16px;">Progress: 0 / ${requiredTaps.length}</div>
  </div>`;
  overlay.querySelectorAll('.tapbtn').forEach(btn=>{
    btn.onclick=()=>{
      const k=Number(btn.dataset.k);
      tapsSoFar.push(k);
      overlay.querySelector('#tapStatus').textContent =
        `Progress: ${tapsSoFar.length} / ${requiredTaps.length}`;
    }
  });
}
function hideOverlay(){ overlay.style.display='none'; }

// ====== Trial intro (overlay BEFORE stimulus) ======
async function showReadyPrompt(){
  overlay.style.display='flex';
  overlay.innerHTML = `<div style="max-width:640px;">
    <h2>Next trial</h2>
    <ol>
      <li><b>Place the stylus in the centre circle</b>. It turns green only when touching the screen.</li>
      <li>Hold the stylus in the centre for <b>3 seconds</b> — a small green dot will appear when registered.</li>
      <li>Then a target will flash. Make a quick <b>flick toward it</b> and <b>return to centre</b>.</li>
      <li>After the delay, reproduce the <b>same direction</b> and <b>return to centre</b>.</li>
    </ol>
    <button id="startTrialBtn">Start trial</button>
  </div>`;
  return new Promise(res=>{
    overlay.querySelector('#startTrialBtn').onclick = ()=>{ overlay.style.display='none'; res(); };
  });
}

// ====== Flow helpers ======
function updateContactState(e){
  // Update contact & in-home with current pointer event
  contact = isContact(e);
  const {x,y} = getCanvasXY(e);
  lastXY = {x,y};
  const dx = x - CX, dy = y - CY;
  const r = Math.hypot(dx,dy);
  inHomeContact = contact && (r <= HOME_SNAP);

  // Handle hold timing
  if(inHomeContact){
    if(holdStart === null){ holdStart = now(); }
    const held = now() - holdStart;
    homeLocked = held >= HOLD_MS;
  } else {
    holdStart = null;
    homeLocked = false;
  }
  drawBase();
}

// Wait until 3s continuous contact in centre (homeLocked)
async function waitForHomeLock(){
  return new Promise(res=>{
    const tick = setInterval(()=>{
      if(homeLocked){ clearInterval(tick); res(); }
    }, 30);
  });
}

// Capture angle at threshold crossing; enforce return to centre (contact-based)
async function waitForStrokeAndReturn(which){
  return new Promise(resolve=>{
    let angleCaptured = false;
    let returned = false;
    const deadline = now() + 20000; // safety

    const poll = setInterval(()=>{
      if(now()>deadline){ clearInterval(poll); resolve(); return; }
      if(which==='encode' && current.encode_angle_deg!=null) angleCaptured = true;
      if(which==='recall' && current.recall_angle_deg!=null) angleCaptured = true;
      if(angleCaptured && inHomeContact){ returned = true; }
      if(angleCaptured && returned){ clearInterval(poll); resolve(); }
    }, 30);
  });
}

// ====== Trial ======
async function runTrial(){
  // Reset home state
  holdStart = null; homeLocked = false;

  await showReadyPrompt(); // overlay-only instructions
  phase='centre'; drawBase();
  await waitForHomeLock(); // require 3s centred contact

  // Choose angle & condition
  const angle = randChoice(ANGLES);
  condition = blockPlan[trialN];

  current = {
    participant: (pidEl.value||''),
    trial: trialN+1, condition,
    target_deg: angle, delay_s: Number(delaySel.value),
    encode_time:null, recall_time:null,
    encode_angle_deg:null, recall_angle_deg:null,
    error_deg:null, visAcc:null, motorTapsMatch:null
  };

  // ENCODE
  drawBase(); drawTarget(angle);
  await sleep(TARGET_MS);
  drawBase();
  phase='encode';
  await waitForStrokeAndReturn('encode');

  // DELAY
  phase='delay';
  const dly = Number(delaySel.value);
  if(condition==='verbal'){
    overlay.style.display='flex';
    overlay.innerHTML = `<div>Please repeat softly: “the… the… the…” until the screen changes.</div>`;
  } else if(condition==='vis'){
    makeVisArray();
    showVisArray(1200);
    await sleep(1200);
  } else if(condition==='motor'){
    makeTapPattern();
    showTapUI();
  }
  await sleep(dly*1000);
  if(condition==='verbal') hideOverlay();
  if(condition==='motor'){
    hideOverlay();
    const ok = requiredTaps.length===tapsSoFar.length && requiredTaps.every((v,i)=> v===tapsSoFar[i]);
    current.motorTapsMatch = ok ? 1 : 0;
  }

  // RECALL
  phase='recall';
  drawBase();
  await waitForStrokeAndReturn('recall');

  if(condition==='vis'){
    const ans = await visProbeQuery();
    const corr = (ans==='same' && !visProbe.change) || (ans==='different' && visProbe.change);
    current.visAcc = corr ? 1 : 0;
  }

  current.error_deg = (current.recall_angle_deg==null) ? null :
    wrapDeg(current.recall_angle_deg - current.target_deg);

  trials.push(current);
  trialN++;
}

// ====== Pointer events ======
// We ONLY consider contact movement (no hover drawing)
canvas.addEventListener('pointerdown', e=>{
  updateContactState(e);
}, {passive:false});

canvas.addEventListener('pointermove', e=>{
  updateContactState(e);
  if((phase==='encode' || phase==='recall') && contact){
    const {x,y} = lastXY;
    const dx = x - CX, dy = y - CY;
    const r = Math.hypot(dx,dy);
    if(r>=R_THRESH){
      const ang = wrapDeg(rad2deg(Math.atan2(dy,dx)));
      if(phase==='encode' && current.encode_angle_deg==null){
        current.encode_angle_deg = ang;
        current.encode_time = Date.now();
      }
      if(phase==='recall' && current.recall_angle_deg==null){
        current.recall_angle_deg = ang;
        current.recall_time = Date.now();
      }
    }
  }
}, {passive:false});

canvas.addEventListener('pointerup', e=>{
  updateContactState(e); // will set contact=false and reset hold if needed
}, {passive:false});

// ====== Block/session & CSV ======
async function runBlock(n=null, label='Block', fixedCond=null){
  pidEl.blur(); pidEl.disabled = true;
  running = true;
  trialN = 0;
  trials = [];
  const nTrials = n ?? Number(nTrialsSel.value);
  blockPlan = makeBlockPlan(condMixSel.value, nTrials, fixedCond);
  startBtn.disabled = true; downloadBtn.disabled = true;

  for(let i=0;i<nTrials;i++){
    await runTrial();
    await sleep(300);
  }

  running = false;
  pidEl.disabled = false;
  startBtn.disabled = false; downloadBtn.disabled = false;

  overlay.style.display='flex';
  overlay.innerHTML = `<div style="max-width:560px; text-align:center;">
    <h2>${label} complete</h2>
    <p>You can now download your data as a CSV file.</p>
    <div style="display:flex; gap:8px; justify-content:center; flex-wrap:wrap; margin-top:10px;">
      <button id="endDownloadBtn">Download CSV</button>
      <button id="againBtn">Repeat this ${label.toLowerCase()}</button>
      <button id="homeBtn">Back to instructions</button>
    </div>
    <p class="note">Participant: ${pidEl.value||'(none)'} • Condition: ${fixedCond?fixedCond:condMixSel.value}
      • Trials: ${nTrials} • Delay: ${Number(delaySel.value)}s</p>
  </div>`;
  document.getElementById('endDownloadBtn').onclick = ()=> downloadCSV();
  document.getElementById('againBtn').onclick = ()=>{ overlay.style.display='none'; runBlock(nTrials, label, fixedCond); };
  document.getElementById('homeBtn').onclick = ()=>{ overlay.style.display='none'; showIntro(); };
}

async function runSessionBlocked(order=['baseline','verbal','vis','motor'], nTrials=null){
  const n = nTrials ?? Number(nTrialsSel.value);
  for(const cond of order){
    overlay.style.display='flex';
    overlay.innerHTML = `<div style="max-width:680px;">
      <h2>Next block: ${cond.toUpperCase()}</h2>
      <p>During the delay you will ${
        cond==='baseline' ? 'do nothing extra.' :
        cond==='verbal'   ? 'softly repeat “the… the… the…”' :
        cond==='vis'      ? 'remember a small coloured pattern' :
                            'tap a short on-screen pattern with your other hand'
      }</p>
      <p>Each trial: centre for 3s → flick toward target → return → delay → reproduce direction → return.</p>
      <button id="goBlock">Start ${cond} block (${n} trials)</button>
    </div>`;
    await new Promise(res=> overlay.querySelector('#goBlock').onclick = ()=>{ overlay.style.display='none'; res(); });
    await runBlock(n, `Block: ${cond}`, cond);
  }
  overlay.style.display='flex';
  overlay.innerHTML = `<div style="max-width:560px; text-align:center;">
    <h2>Session complete</h2>
    <p>Download your data before exiting.</p>
    <div style="display:flex; gap:8px; justify-content:center; flex-wrap:wrap; margin-top:10px;">
      <button id="endDownloadBtn2">Download CSV</button>
      <button id="homeBtn2">Back to instructions</button>
    </div>
    <p class="note">Participant: ${pidEl.value||'(none)'}</p>
  </div>`;
  document.getElementById('endDownloadBtn2').onclick = ()=> downloadCSV();
  document.getElementById('homeBtn2').onclick = ()=>{ overlay.style.display='none'; showIntro(); };
}

function toCSV(){
  const fields = [
    'participant','trial','condition','target_deg','delay_s',
    'encode_angle_deg','recall_angle_deg','error_deg',
    'visAcc','motorTapsMatch','encode_time','recall_time'
  ];
  let rows = [fields.join(',')];
  for(const r of trials){
    rows.push(fields.map(k=> (r[k]==null?'':r[k])).join(','));
  }
  return rows.join('\\n');
}
function downloadCSV(){
  const blob = new Blob([toCSV()], {type:'text/csv'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  const id = pidEl.value ? `_PID-${pidEl.value}` : '';
  a.href = url; a.download = `mwm_reach${id}_${Date.now()}.csv`;
  document.body.appendChild(a); a.click(); a.remove();
  URL.revokeObjectURL(url);
}

// ====== Intro ======
function showIntro(){
  overlay.style.display='flex';
  overlay.innerHTML = `<div style="max-width:700px;">
    <h2>Motor Working Memory – Delayed Reach</h2>
    <ol>
      <li>Place the stylus in the centre. It turns green only when touching the screen.</li>
      <li>Hold in the centre for <b>3 seconds</b> (a small green dot confirms), then the target will flash.</li>
      <li>Flick toward the target and return to centre. After the delay, reproduce the same direction and return.</li>
    </ol>
    <div style="margin-top:14px; display:flex; gap:8px; flex-wrap:wrap;">
      <button id="startDemoBtn">Quick demo (5 random trials)</button>
      <button id="startBlockBtn">Single block (use toolbar settings)</button>
      <button id="startSessionBtn">Blocked session (Baseline → Verbal → Vis → Motor)</button>
    </div>
  </div>`;
  document.getElementById('startDemoBtn').onclick   = ()=>{ overlay.style.display='none'; runBlock(5, 'Demo'); };
  document.getElementById('startBlockBtn').onclick  = ()=>{ overlay.style.display='none'; runBlock(Number(nTrialsSel.value), 'Block'); };
  document.getElementById('startSessionBtn').onclick= ()=>{
    overlay.style.display='none';
    runSessionBlocked(['baseline','verbal','vis','motor'], Number(nTrialsSel.value));
  };
}

// ====== Wire up toolbar ======
startBtn.onclick = ()=> { if(!running) runBlock(Number(nTrialsSel.value), 'Block'); };
downloadBtn.onclick = downloadCSV;

// ====== Init ======
drawBase();
showIntro();
</script>
</body>
</html>
